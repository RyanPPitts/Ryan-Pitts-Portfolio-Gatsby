var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var Interfaces_1 = require("../Interfaces");
var makeExecutableSchema_1 = require("../makeExecutableSchema");
var delegateToSchema_1 = __importDefault(require("./delegateToSchema"));
var typeFromAST_1 = __importDefault(require("./typeFromAST"));
var transforms_1 = require("../transforms");
var utils_1 = require("../utils");
function mergeSchemas(_a) {
    var _b = _a.subschemas, subschemas = _b === void 0 ? [] : _b, _c = _a.types, types = _c === void 0 ? [] : _c, typeDefs = _a.typeDefs, _d = _a.schemas, schemaLikeObjects = _d === void 0 ? [] : _d, _e = _a.mergeTypes, mergeTypes = _e === void 0 ? [] : _e, onTypeConflict = _a.onTypeConflict, _f = _a.resolvers, resolvers = _f === void 0 ? {} : _f, schemaDirectives = _a.schemaDirectives, inheritResolversFromInterfaces = _a.inheritResolversFromInterfaces, mergeDirectives = _a.mergeDirectives;
    var allSchemas = [];
    var typeCandidates = {};
    var typeMap = {};
    var extensions = [];
    var directives = [];
    var schemas = __spreadArrays(subschemas);
    if (typeDefs) {
        schemas.push(typeDefs);
    }
    if (types) {
        schemas.push(types);
    }
    schemas = __spreadArrays(schemas, schemaLikeObjects);
    schemas.forEach(function (schemaLikeObject) {
        if (schemaLikeObject instanceof graphql_1.GraphQLSchema || Interfaces_1.isSubschemaConfig(schemaLikeObject)) {
            var schema_1 = transforms_1.wrapSchema(schemaLikeObject);
            allSchemas.push(schema_1);
            var operationTypes_1 = {
                Query: schema_1.getQueryType(),
                Mutation: schema_1.getMutationType(),
                Subscription: schema_1.getSubscriptionType(),
            };
            Object.keys(operationTypes_1).forEach(function (typeName) {
                if (operationTypes_1[typeName]) {
                    addTypeCandidate(typeCandidates, typeName, {
                        schema: schema_1,
                        type: operationTypes_1[typeName],
                        subschema: schemaLikeObject,
                    });
                }
            });
            if (mergeDirectives) {
                var directiveInstances = schema_1.getDirectives();
                directiveInstances.forEach(function (directive) {
                    directives.push(directive);
                });
            }
            var originalTypeMap_1 = schema_1.getTypeMap();
            Object.keys(originalTypeMap_1).forEach(function (typeName) {
                var type = originalTypeMap_1[typeName];
                if (graphql_1.isNamedType(type) &&
                    graphql_1.getNamedType(type).name.slice(0, 2) !== '__' &&
                    type !== operationTypes_1.Query &&
                    type !== operationTypes_1.Mutation &&
                    type !== operationTypes_1.Subscription) {
                    addTypeCandidate(typeCandidates, type.name, {
                        schema: schema_1,
                        type: type,
                        subschema: schemaLikeObject,
                    });
                }
            });
        }
        else if (typeof schemaLikeObject === 'string' ||
            (schemaLikeObject && schemaLikeObject.kind === graphql_1.Kind.DOCUMENT)) {
            var parsedSchemaDocument = typeof schemaLikeObject === 'string' ? graphql_1.parse(schemaLikeObject) : schemaLikeObject;
            parsedSchemaDocument.definitions.forEach(function (def) {
                var type = typeFromAST_1.default(def);
                if (type instanceof graphql_1.GraphQLDirective && mergeDirectives) {
                    directives.push(type);
                }
                else if (type && !(type instanceof graphql_1.GraphQLDirective)) {
                    addTypeCandidate(typeCandidates, type.name, {
                        type: type,
                    });
                }
            });
            var extensionsDocument = makeExecutableSchema_1.extractExtensionDefinitions(parsedSchemaDocument);
            if (extensionsDocument.definitions.length > 0) {
                extensions.push(extensionsDocument);
            }
        }
        else if (Array.isArray(schemaLikeObject)) {
            schemaLikeObject.forEach(function (type) {
                addTypeCandidate(typeCandidates, type.name, {
                    type: type,
                });
            });
        }
        else {
            throw new Error("Invalid schema passed");
        }
    });
    Object.keys(typeCandidates).forEach(function (typeName) {
        if (typeName === 'Query' ||
            typeName === 'Mutation' ||
            typeName === 'Subscription' ||
            mergeTypes.includes(typeName)) {
            typeMap[typeName] = mergeFields(typeName, typeCandidates[typeName]);
        }
        else {
            var candidateSelector = onTypeConflict ?
                onTypeConflictToCandidateSelector(onTypeConflict) :
                function (cands) { return cands[cands.length - 1]; };
            typeMap[typeName] = candidateSelector(typeCandidates[typeName]).type;
        }
    });
    utils_1.healTypes(typeMap, directives, { skipPruning: true });
    var mergedSchema = new graphql_1.GraphQLSchema({
        query: typeMap.Query,
        mutation: typeMap.Mutation,
        subscription: typeMap.Subscription,
        types: Object.keys(typeMap).map(function (key) { return typeMap[key]; }),
        directives: directives.length ?
            directives.map(function (directive) { return utils_1.cloneDirective(directive); }) :
            undefined
    });
    extensions.forEach(function (extension) {
        mergedSchema = graphql_1.extendSchema(mergedSchema, extension, {
            commentDescriptions: true,
        });
    });
    var mergeInfo = createMergeInfo(allSchemas, mergeTypes, typeCandidates);
    if (typeof resolvers === 'function') {
        console.warn('Passing functions as resolver parameter is deprecated. Use `info.mergeInfo` instead.');
        resolvers = resolvers(mergeInfo) || {};
    }
    else if (Array.isArray(resolvers)) {
        resolvers = resolvers.reduce(function (left, right) {
            if (typeof right === 'function') {
                console.warn('Passing functions as resolver parameter is deprecated. Use `info.mergeInfo` instead.');
                right = right(mergeInfo);
            }
            return utils_1.mergeDeep(left, right);
        }, {}) || {};
        if (!resolvers) {
            resolvers = {};
        }
        else if (Array.isArray(resolvers)) {
            resolvers = resolvers.reduce(utils_1.mergeDeep, {});
        }
    }
    mergeInfo = completeMergeInfo(mergeInfo, resolvers);
    makeExecutableSchema_1.addResolversToSchema({
        schema: mergedSchema,
        resolvers: resolvers,
        inheritResolversFromInterfaces: inheritResolversFromInterfaces
    });
    utils_1.forEachField(mergedSchema, function (field) {
        if (field.resolve) {
            var fieldResolver_1 = field.resolve;
            field.resolve = function (parent, args, context, info) {
                var newInfo = __assign(__assign({}, info), { mergeInfo: mergeInfo });
                return fieldResolver_1(parent, args, context, newInfo);
            };
        }
        if (field.subscribe) {
            var fieldResolver_2 = field.subscribe;
            field.subscribe = function (parent, args, context, info) {
                var newInfo = __assign(__assign({}, info), { mergeInfo: mergeInfo });
                return fieldResolver_2(parent, args, context, newInfo);
            };
        }
    });
    if (schemaDirectives) {
        utils_1.SchemaDirectiveVisitor.visitSchemaDirectives(mergedSchema, schemaDirectives);
    }
    utils_1.healSchema(mergedSchema);
    return mergedSchema;
}
exports.default = mergeSchemas;
function createMergeInfo(allSchemas, mergeTypes, typeCandidates) {
    var mergedTypes = {};
    mergeTypes.forEach(function (typeName) {
        if (typeCandidates[typeName]) {
            var subschemaConfigs = typeCandidates[typeName]
                .filter(function (typeCandidate) { return Interfaces_1.isSubschemaConfig(typeCandidate.subschema); })
                .map(function (typeCandidate) { return typeCandidate.subschema; });
            var inlineFragments = subschemaConfigs
                .filter(function (subschemaConfig) { return subschemaConfig.mergedTypeConfigs[typeName].fragment; })
                .map(function (subschemaConfig) { return subschemaConfig.mergedTypeConfigs[typeName].fragment; })
                .map(function (fragment) { return utils_1.parseFragmentToInlineFragment(fragment); });
            mergedTypes[typeName] = {
                fragment: utils_1.concatInlineFragments(typeName, inlineFragments),
                subschemas: subschemaConfigs,
            };
        }
        else {
            throw new Error("Cannot merge type '" + typeName + "', type not found.");
        }
    });
    return {
        delegate: function (operation, fieldName, args, context, info, transforms) {
            console.warn('`mergeInfo.delegate` is deprecated. ' +
                'Use `mergeInfo.delegateToSchema and pass explicit schema instances.');
            var schema = guessSchemaByRootField(allSchemas, operation, fieldName);
            var expandTransforms = new transforms_1.ExpandAbstractTypes(info.schema, schema);
            var fragmentTransform = new transforms_1.AddReplacementFragments(schema, info.mergeInfo.replacementFragments);
            return delegateToSchema_1.default({
                schema: schema,
                operation: operation,
                fieldName: fieldName,
                args: args,
                context: context,
                info: info,
                transforms: __spreadArrays((transforms || []), [
                    expandTransforms,
                    fragmentTransform,
                ]),
            });
        },
        delegateToSchema: function (options) {
            return delegateToSchema_1.default(__assign(__assign({}, options), { transforms: options.transforms }));
        },
        fragments: [],
        replacementFragments: undefined,
        mergedTypes: mergedTypes,
    };
}
function completeMergeInfo(mergeInfo, resolvers) {
    Object.keys(resolvers).forEach(function (typeName) {
        var type = resolvers[typeName];
        if (type instanceof graphql_1.GraphQLScalarType) {
            return;
        }
        Object.keys(type).forEach(function (fieldName) {
            var field = type[fieldName];
            if (field.fragment) {
                mergeInfo.fragments.push({
                    field: fieldName,
                    fragment: field.fragment,
                });
            }
        });
    });
    var mapping = {};
    mergeInfo.fragments.forEach(function (_a) {
        var field = _a.field, fragment = _a.fragment;
        var parsedFragment = utils_1.parseFragmentToInlineFragment(fragment);
        var actualTypeName = parsedFragment.typeCondition.name.value;
        mapping[actualTypeName] = mapping[actualTypeName] || {};
        mapping[actualTypeName][field] = mapping[actualTypeName][field] || [];
        mapping[actualTypeName][field].push(parsedFragment);
    });
    var replacementFragments = Object.create({});
    Object.keys(mapping).forEach(function (typeName) {
        Object.keys(mapping[typeName]).forEach(function (field) {
            replacementFragments[typeName] = mapping[typeName] || {};
            replacementFragments[typeName][field] = utils_1.concatInlineFragments(typeName, mapping[typeName][field]);
        });
    });
    mergeInfo.replacementFragments = replacementFragments;
    return mergeInfo;
}
function guessSchemaByRootField(schemas, operation, fieldName) {
    for (var _i = 0, schemas_1 = schemas; _i < schemas_1.length; _i++) {
        var schema = schemas_1[_i];
        var rootObject = operationToRootType(operation, schema);
        if (rootObject) {
            var fields = rootObject.getFields();
            if (fields[fieldName]) {
                return schema;
            }
        }
    }
    throw new Error("Could not find subschema with field `" + operation + "." + fieldName + "`");
}
function addTypeCandidate(typeCandidates, name, typeCandidate) {
    if (!typeCandidates[name]) {
        typeCandidates[name] = [];
    }
    typeCandidates[name].push(typeCandidate);
}
function onTypeConflictToCandidateSelector(onTypeConflict) {
    return function (cands) {
        return cands.reduce(function (prev, next) {
            var type = onTypeConflict(prev.type, next.type, {
                left: {
                    schema: prev.schema,
                },
                right: {
                    schema: next.schema,
                },
            });
            if (prev.type === type) {
                return prev;
            }
            else if (next.type === type) {
                return next;
            }
            else {
                return {
                    schemaName: 'unknown',
                    type: type
                };
            }
        });
    };
}
function operationToRootType(operation, schema) {
    if (operation === 'subscription') {
        return schema.getSubscriptionType();
    }
    else if (operation === 'mutation') {
        return schema.getMutationType();
    }
    else {
        return schema.getQueryType();
    }
}
function mergeFields(typeName, candidates) {
    return new graphql_1.GraphQLObjectType({
        name: typeName,
        fields: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), candidate.type.toConfig().fields)); }, {}),
    });
}
//# sourceMappingURL=mergeSchemas.js.map